# George Miloshevich 2021
# This routine is written for two parameters: input folder for VAE weights and the given epoch. It shows us how good the reconstruction of the VAE works
import os, sys
import shutil

os.environ['TF_XLA_FLAGS'] = '--tf_xla_enable_xla_devices'  # https://stackoverflow.com/questions/65907365/tensorflow-not-creating-xla-devices-tf-xla-enable-xla-devices-not-set


checkpoint_name = sys.argv[1]  # The name of the folder where the weights have been stored
checkpoint = sys.argv[2]       # The checkpoint at which the weights have been stored

import importlib.util
def module_from_file(module_name, file_path): #The code that imports the file which originated the training with all the instructions
            spec = importlib.util.spec_from_file_location(module_name, file_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            return module
        
print("checkpoint_name = ", checkpoint_name)
print("loading module from ", checkpoint_name+'/Funs.py')
from importlib import import_module
#foo = import_module(checkpoint_name+'/Funs.py', package=None)
foo = module_from_file("foo", checkpoint_name+'/Funs.py')
ef = foo.ef # Inherit ERA_Fields_New from the file we are calling

print("==Importing tensorflow packages===")
import random as rd  
from scipy.stats import norm
import numpy as np

tff = foo.tff # tensorflow routines 
ut = foo.ut # utilities
print("==Checking GPU==")
import tensorflow as tf
tf.test.is_gpu_available(
    cuda_only=False, min_cuda_compute_capability=None
)

print("==Checking CUDA==")
tf.test.is_built_with_cuda()

import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
import cartopy.mpl.geoaxes

import matplotlib.gridspec as gridspec
import cartopy.crs as ccrs
import cartopy.feature as cfeat
data_proj = ccrs.PlateCarree()

#from tensorflow.keras.preprocessing.image import ImageDataGenerator
sys.path.insert(1, '../ERA')
import cartopy_plots as cplt


print("==Reading data==")

year_permutation = np.load(checkpoint_name+'/year_permutation.npy')

#X, lat, lon, vae, Z_DIM, N_EPOCHS, INITIAL_EPOCH, BATCH_SIZE, LEARNING_RATE, checkpoint_path, checkpoint_name, myinput, history = foo.PrepareDataAndVAE(checkpoint_name, DIFFERENT_YEARS=year_permutation[:800])
X, lat, lon, vae, N_EPOCHS, INITIAL_EPOCH, BATCH_SIZE, LEARNING_RATE, checkpoint_path, checkpoint_name, myinput, history = foo.PrepareDataAndVAE(checkpoint_name, DIFFERENT_YEARS=year_permutation[:800])
# Construct 2D array for lon-lat:
LON, LAT = np.meshgrid(lon,lat)
print("X.shape = ", X.shape, " , np.max(X) = ", np.max(X), " , np.min (X) = ", np.min(X), " , np.mean(X[:,5,5,0]) = ", np.mean(X[:,5,5,0]), " , np.std(X[:,5,5,0]) = ", np.std(X[:,5,5,0]))
print("==loading the model: ", checkpoint_name)
vae = tf.keras.models.load_model(checkpoint_name, compile=False)

nb_zeros_c = 4-len(str(checkpoint))
checkpoint_i = '/cp-'+nb_zeros_c*'0'+str(checkpoint)+'.ckpt'

vae.load_weights(checkpoint_name+checkpoint_i)
      
example_images = X[rd.sample(range(X.shape[0]), 5)]

_,_,z_test = vae.encoder.predict(X[rd.sample(range(X.shape[0]), 200)])
print("z_test.shape = ", z_test.shape)

Z_DIM = z_test.shape[1] #200 # Dimension of the latent vector (z)
x = np.linspace(-3, 3, 300)

fig = plt.figure(figsize=(20, 20))
fig.subplots_adjust(hspace=0.6, wspace=0.4)

for i in range(np.min([50, Z_DIM])):
    ax = fig.add_subplot(5, 10, i+1)
    ax.hist(z_test[:,i], density=True, bins = 20)
    ax.axis('off')
    ax.text(0.5, -0.35, str(i), fontsize=10, ha='center', transform=ax.transAxes)
    ax.plot(x,norm.pdf(x))

#WEIGHTS_FOLDER, RESCALE_TYPE, Z_DIM, BATCH_SIZE, LEARNING_RATE, N_EPOCHS, SET_YEARS, K1, K2, checkpoint_name, data_path, Model, lon_start, lon_end, lat_start, lat_end, Tot_Mon1 = foo.PrepareParameters(checkpoint_name)

def vae_generate_images(vae,Z_DIM,n_to_show=10):
    # Plot images generated by the autoencoder
    reconst_images = vae.decoder.predict(np.random.normal(0,1,size=(n_to_show,Z_DIM)))
    
    # prerolling has already occured so
    reconst_images1 = reconst_images[...,1] # remove extra fields 
    reconst_images0 = reconst_images[...,2] # remove extra fields 
    print("reconst_images.shape = ",reconst_images.shape)
    
    levels = np.linspace(0, 1, 64)
    print("levels = ", levels)
    fig2 = plt.figure(figsize=(40, 10))
    spec2 = gridspec.GridSpec(ncols=5, nrows=2, figure=fig2)
    iterate = 0
    jterate = 0
    ax = []
    for i in range(n_to_show):
        m = fig2.add_subplot(spec2[jterate,iterate], projection=ccrs.Orthographic(central_latitude=90))
        ax.append(m)
        img1 = reconst_images1[i].squeeze()   
        img0 = reconst_images0[i].squeeze()   
        print("LON.shape = ", LON.shape, " ,LAT.shape = ", LAT.shape, " ,img0.shape = ", img0.shape, " ,img1.shape = ", img1.shape)
        print(iterate,jterate,img0.shape,img0.min(), img0.max())
        m.set_extent([-180,180, 30, 90], crs=data_proj)
        ef.geo_contourf(m, ax[iterate], 0, *cplt.Greenwich(LON, LAT,img0),levels, "seismic", f" generated zg500", put_colorbar=False, draw_gridlines=False)
        ef.geo_contour (m, ax[iterate], 0, *cplt.Greenwich(LON, LAT,img1),levels, "PuRd", "summer")
        
        axins = inset_axes(m, width="40%", height="40%", loc="upper right", 
                   axes_class=cartopy.mpl.geoaxes.GeoAxes, 
                   axes_kwargs=dict(map_projection=cartopy.crs.PlateCarree()))
        
        axins.add_feature(cartopy.feature.COASTLINE)
        axins.set_extent([-10,10, 40, 60], crs=data_proj)
        ef.geo_contourf(axins, ax[iterate], 0, *cplt.Greenwich(LON, LAT,img0),levels, "seismic", "", put_colorbar=False, draw_gridlines=False)
        ef.geo_contour (axins, ax[iterate], 0, *cplt.Greenwich(LON, LAT,img1),levels, "PuRd", "summer")
        iterate += 1
        if iterate > 4:
            iterate = 0
            jterate = 1
        
        
vae_generate_images(vae,Z_DIM,n_to_show=10)


def plot_compare(model, images=None): 
    # Plot images as well as their reconstruction
    model.encoder(images)
    mean, logvar, z_sample = model.encoder(images)
    reconst_images = model.decoder(z_sample).numpy()
    
    
    reconst_images1 = reconst_images[...,1] # remove extra fields 
    reconst_images0 = reconst_images[...,2] # remove extra fields 
    print("reconst_images.shape = ",reconst_images.shape)
    
    images1 = images[...,1]
    images0 = images[...,2]
    print("images0.shape = ",images0.shape)
    
    
    #print("reconst_images.shape=",reconst_images.shape)
    n_to_show = 2*images0.shape[0]
    
    levels = np.linspace(0, 1, 64)
    print("levels = ", levels)
    fig2 = plt.figure(figsize=(40, 10))
    spec2 = gridspec.GridSpec(ncols=5, nrows=2, figure=fig2)
    iterate = 0
    jterate = 0
    ax = []
    for i in range(n_to_show):
        m = fig2.add_subplot(spec2[jterate,iterate], projection=ccrs.Orthographic(central_latitude=90))
        ax.append(m)
        if jterate == 0:
            img1 = images1[i].squeeze() 
            img0 = images0[i].squeeze() 
        else:
            img1 = reconst_images1[i-5].squeeze()  
            img0 = reconst_images0[i-5].squeeze()  
        print(iterate,jterate,img0.shape,img0.min(), img0.max())
        m.set_extent([-180,180, 30, 90], crs=data_proj)
        
        axins = inset_axes(m, width="50%", height="50%", loc="upper right", 
                   axes_class=cartopy.mpl.geoaxes.GeoAxes, 
                   axes_kwargs=dict(map_projection=cartopy.crs.PlateCarree()))
        axins.add_feature(cartopy.feature.COASTLINE)
        axins.set_extent([-10,10, 40, 60], crs=data_proj)
        print("LON.shape = ", LON.shape, " ,LAT.shape = ", LAT.shape, " ,img0.shape = ", img0.shape, " ,img1.shape = ", img1.shape)
        if jterate == 0:
            ef.geo_contourf(m, ax[iterate], 0, *cplt.Greenwich(LON, LAT,img0),levels, "seismic", f"actual", put_colorbar=False, draw_gridlines=False)
            ef.geo_contour (m, ax[iterate], 0, *cplt.Greenwich(LON, LAT,img1),levels, "PuRd", "summer")
            ef.geo_contourf(axins, ax[iterate], 0, *cplt.Greenwich(LON, LAT,img0),levels, "seismic", "", put_colorbar=False, draw_gridlines=False)
        else:
            ef.geo_contourf(m, ax[iterate], 0, *cplt.Greenwich(LON, LAT,img0),levels, "seismic", f"reconstructed", put_colorbar=False, draw_gridlines=False)
            ef.geo_contour (m, ax[iterate], 0, *cplt.Greenwich(LON, LAT,img1),levels, "PuRd", "summer")
            ef.geo_contourf(axins, ax[iterate], 0, *cplt.Greenwich(LON, LAT,img0),levels, "seismic", "", put_colorbar=False, draw_gridlines=False)
        
        ef.geo_contour (axins, ax[iterate], 0, *cplt.Greenwich(LON, LAT,img1),levels, "PuRd", "summer")
        
        iterate += 1
        if iterate > 4:
            iterate = 0
            jterate = 1

        
plot_compare(vae,example_images)

plt.show()

